import { backgroundTaskManager } from '@kit.BackgroundTasksKit';
import { wantAgent } from '@kit.AbilityKit';
import { common } from '@kit.AbilityKit';
import { media } from '@kit.MediaKit';
import { audio } from '@kit.AudioKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { avSession as AVSessionManager } from '@kit.AVSessionKit'; // âœ… å¼•å…¥ AVSessionKit
import { NotificationHelper } from './NotificationHelper';
import { ReminderHelper } from './ReminderHelper';
import { FileLogger } from './FileLogger'; // âœ… å¼•å…¥æ—¥å¿—å·¥å…·

export class GuardianService {
  private static instance: GuardianService;
  private context: common.UIAbilityContext | undefined;
  
  // å®ˆæŠ¤çŠ¶æ€
  private isRunning: boolean = false;
  
  // è®¡æ—¶å™¨ç›¸å…³
  private secondsRemaining: number = 0;
  private totalSeconds: number = 0;
  private isPaused: boolean = false;
  private targetEndTime: number = 0;

  // âœ… éŸ³é¢‘é©±åŠ¨æ ¸å¿ƒ
  private audioDriver: media.AVPlayer | undefined;
  private lastTickTime: number = 0;
  
  // âœ… AVSession ä¿æ´»æ ¸å¿ƒ
  private session: AVSessionManager.AVSession | undefined;

  private constructor() {}

  public static getInstance(): GuardianService {
    if (!GuardianService.instance) {
      GuardianService.instance = new GuardianService();
    }
    return GuardianService.instance;
  }

  // âœ… æ–°å¢ï¼šåŒæ­¥æŸ¥è¯¢æ˜¯å¦åœ¨è¿è¡Œï¼ˆæ¯” StorageProp æ›´å¿«æ›´å‡†ï¼‰
  public isTimerRunning(): boolean {
    return this.isRunning; // isRunning å·²ç»åœ¨å†…éƒ¨ç»´æŠ¤äº†
  }

  public init(context: common.UIAbilityContext) {
    this.context = context;
    FileLogger.init(context); // åˆå§‹åŒ–æ—¥å¿—
    
    AppStorage.setOrCreate('GS_SecondsRemaining', 0);
    AppStorage.setOrCreate('GS_TotalSeconds', 0);
    AppStorage.setOrCreate('GS_IsPaused', false);
    AppStorage.setOrCreate('GS_IsRunning', false);
    
    FileLogger.write('Init', 'æœåŠ¡åˆå§‹åŒ–å®Œæˆ');
  }

  // --- å¤–éƒ¨æ§åˆ¶æ¥å£ ---

  public async startTimer(durationSeconds?: number) {
    if (!this.context) return;
    FileLogger.write('Action', `è¯·æ±‚å¼€å§‹è®¡æ—¶, duration=${durationSeconds}`);

    // 1. ç”³è¯·åå°é•¿æ—¶ä»»åŠ¡
    await this.requestBackgroundTask();

    // 2. åˆå§‹åŒ–æˆ–æ¢å¤æ•°æ®
    if (durationSeconds !== undefined) {
      this.totalSeconds = durationSeconds;
      this.secondsRemaining = durationSeconds;
      this.isPaused = false;
    } else {
      this.isPaused = false;
    }

    // æ›´æ–°çŠ¶æ€åˆ° UI
    this.syncToAppStorage(true);

    // 3. è®¡ç®—ç›®æ ‡ç»“æŸæ—¶é—´
    const now = new Date().getTime();
    this.targetEndTime = now + (this.secondsRemaining * 1000);
    this.lastTickTime = now;

    // 4. è®¾ç½®ç³»ç»Ÿä»£ç†æé†’ (å…œåº•)
    await ReminderHelper.publishTimerReminder(this.context, this.secondsRemaining);

    // 5. å¯åŠ¨éŸ³é¢‘é©±åŠ¨ (æ›¿ä»£ setInterval)
    await this.startAudioDriver();
    
    // 6. åˆ›å»ºå¹¶æ¿€æ´» AVSession (æ ¸å¿ƒä¿æ´»)
    await this.createAVSession();
  }

  public async pauseTimer() {
    FileLogger.write('Action', 'æš‚åœè®¡æ—¶');
    this.isPaused = true;
    this.targetEndTime = 0;
    
    // æš‚åœæ—¶åœæ­¢éŸ³é¢‘é©±åŠ¨
    await this.stopAudioDriver();
    await this.stopBackgroundTask(); // æ”¾å¼ƒåå°æƒé™
    await this.destroyAVSession(); // é”€æ¯ä¼šè¯
    
    await ReminderHelper.cancelAllReminders();
    this.syncToAppStorage(false);
  }

  public async stopTimer(isFinish: boolean = false) {
    // ğŸ” å¢åŠ è°ƒç”¨æ ˆè¿½è¸ªï¼Œæªå‡ºå‡¶æ‰‹ï¼
    const stack = new Error().stack;
    FileLogger.write('Action', `åœæ­¢è®¡æ—¶ isFinish=${isFinish}, Caller:\n${stack}`);
    
    this.secondsRemaining = 0;
    this.targetEndTime = 0;
    this.isPaused = false;

    // åœæ­¢åå°ä»»åŠ¡ï¼ˆä½†ä¿ç•™ Audio å¦‚æœæ˜¯ Finish çŠ¶æ€ï¼‰
    await this.stopBackgroundTask();
    
    // é”€æ¯ AVSession (ä»»åŠ¡ç»“æŸäº†ï¼Œæ’­æ§æ¡ä¹Ÿè¯¥æ²¡äº†ï¼Œæˆ–è€…ä¿ç•™ï¼Ÿé€šå¸¸ç»“æŸäº†å°±æ²¡äº†)
    await this.destroyAVSession();
    
    await NotificationHelper.cancelNotification();
    await ReminderHelper.cancelAllReminders();
    
    if (isFinish) {
        // âœ… ä»»åŠ¡å®Œæˆï¼šåˆ‡æ¢åˆ°é—¹é“ƒæ¨¡å¼ (å¤ç”¨é©±åŠ¨)
        await this.switchToAlarm();
        await NotificationHelper.publishFinishNotification();
    } else {
        // âŒ æ‰‹åŠ¨ç»ˆæ­¢ï¼šå®Œå…¨åœæ­¢
        await this.stopAudioDriver();
        if (this.context) await NotificationHelper.stopAlarm();
    }

    this.syncToAppStorage(false);
  }

  // --- AVSession ä¿æ´»é€»è¾‘ ---

  private async createAVSession() {
    if (!this.context) return;
    try {
      this.session = await AVSessionManager.createAVSession(this.context, 'GuardianSession', 'audio');
      await this.session.activate();
      
      // è®¾ç½®å…ƒæ•°æ®
      let metadata: AVSessionManager.AVMetadata = {
        assetId: '0',
        title: 'ä¸“æ³¨è®¡æ—¶ä¸­',
        artist: 'Better',
        duration: this.totalSeconds * 1000
      };
      await this.session.setAVMetadata(metadata);
      
      // è®¾ç½®æ’­æ”¾çŠ¶æ€ï¼šæ’­æ”¾ä¸­ï¼Œé€Ÿåº¦1.0
      let playbackState: AVSessionManager.AVPlaybackState = {
        state: AVSessionManager.PlaybackState.PLAYBACK_STATE_PLAY,
        position: {
          elapsedTime: 0,
          updateTime: new Date().getTime()
        },
        speed: 1.0,
        bufferedTime: 0,
        duration: this.totalSeconds * 1000
      };
      await this.session.setAVPlaybackState(playbackState);

      FileLogger.write('System', 'AVSession åˆ›å»ºå¹¶æ¿€æ´»æˆåŠŸ');
    } catch (e) {
      FileLogger.write('SystemError', 'AVSession åˆ›å»ºå¤±è´¥: ' + JSON.stringify(e));
    }
  }

  private async destroyAVSession() {
    if (this.session) {
      try {
        await this.session.destroy();
        this.session = undefined;
        FileLogger.write('System', 'AVSession å·²é”€æ¯');
      } catch (e) {
        FileLogger.write('SystemError', 'AVSession é”€æ¯å¤±è´¥: ' + JSON.stringify(e));
      }
    }
  }

  // --- éŸ³é¢‘é©±åŠ¨æ ¸å¿ƒé€»è¾‘ ---

  private async startAudioDriver() {
    if (this.audioDriver) {
      await this.audioDriver.reset();
    } else {
      this.audioDriver = await media.createAVPlayer();
    }

    this.audioDriver.on('stateChange', async (state) => {
      switch (state) {
        case 'initialized':
          this.audioDriver!.audioRendererInfo = {
            usage: audio.StreamUsage.STREAM_USAGE_MUSIC,
            rendererFlags: 0
          };
          await this.audioDriver!.prepare();
          break;
        case 'prepared':
          this.audioDriver!.loop = true;
          // å¦‚æœæ˜¯é—¹é“ƒæ¨¡å¼ï¼ŒéŸ³é‡è®¾ä¸º 1.0ï¼Œå¦åˆ™ 0.01
          // è¿™é‡Œé€šè¿‡ä¸€ä¸ªæ ‡è®°ä½æˆ–è€…ç®€å•çš„é€»è¾‘åˆ¤æ–­ï¼Ÿ
          // ç®€å•èµ·è§ï¼ŒstartAudioDriver é»˜è®¤æ˜¯é™éŸ³ä¿æ´»ã€‚é—¹é“ƒé€»è¾‘å•ç‹¬å¤„ç†ã€‚
          this.audioDriver!.setVolume(0.01); 
          await this.audioDriver!.play();
          FileLogger.write('Audio', 'é©±åŠ¨å·²å¯åŠ¨ (Playing)');
          break;
        case 'error':
          FileLogger.write('AudioError', 'æ’­æ”¾å™¨å‡ºé”™');
          break;
      }
    });

    this.audioDriver.on('timeUpdate', (time: number) => {
       const now = Date.now();
       if (now - this.lastTickTime >= 1000) {
           this.tick();
           this.lastTickTime = now;
       }
    });

    try {
      if (this.context) {
        let fileDescriptor = await this.context.resourceManager.getRawFd('silence.mp3');
        this.audioDriver.fdSrc = fileDescriptor;
      }
    } catch (e) {
      FileLogger.write('AudioError', 'åŠ è½½ silence.mp3 å¤±è´¥: ' + JSON.stringify(e));
    }
  }
  
  // âœ… åˆ‡æ¢åˆ°é—¹é“ƒæ¨¡å¼ (å¤ç”¨é©±åŠ¨)
  private async switchToAlarm() {
    if (!this.audioDriver || !this.context) return;
    FileLogger.write('Audio', 'åˆ‡æ¢åˆ°é—¹é“ƒæ¨¡å¼');
    
    // ç§»é™¤ timeUpdate ç›‘å¬ï¼Œé˜²æ­¢é—¹é“ƒæ—¶è¿˜åœ¨ tick
    this.audioDriver.off('timeUpdate');
    
    await this.audioDriver.reset();
    
    // é‡æ–°é…ç½®å›è°ƒ (å› ä¸º reset å state ä¼šå˜)
    this.audioDriver.on('stateChange', async (state) => {
      switch (state) {
        case 'initialized':
           // é—¹é“ƒç”¨ ALARM æµ
           this.audioDriver!.audioRendererInfo = {
            usage: audio.StreamUsage.STREAM_USAGE_ALARM,
            rendererFlags: 0
          };
          await this.audioDriver!.prepare();
          break;
        case 'prepared':
          this.audioDriver!.loop = true;
          this.audioDriver!.setVolume(1.0); // æœ€å¤§éŸ³é‡
          await this.audioDriver!.play();
          
          // åŒæ—¶å¼€å¯éœ‡åŠ¨
          NotificationHelper.startVibrationLoop();
          break;
      }
    });
    
    try {
        let fileDescriptor = await this.context.resourceManager.getRawFd('alarm.mp3');
        this.audioDriver.fdSrc = fileDescriptor;
    } catch(e) {
        FileLogger.write('AudioError', 'åŠ è½½ alarm.mp3 å¤±è´¥');
    }
  }

  private async stopAudioDriver() {
    if (this.audioDriver) {
      try {
        await this.audioDriver.stop();
        await this.audioDriver.release();
        this.audioDriver = undefined;
        FileLogger.write('Audio', 'é©±åŠ¨å·²åœæ­¢');
      } catch (e) {
        FileLogger.write('AudioError', 'åœæ­¢å¤±è´¥: ' + JSON.stringify(e));
      }
    }
  }

  // --- ä¸šåŠ¡é€»è¾‘ ---

  private tick() {
    if (this.isPaused) return;

    const now = new Date().getTime();
    const diff = Math.ceil((this.targetEndTime - now) / 1000);

    // è®°å½•å¿ƒè·³æ—¥å¿— (æ¯10ç§’è®°ä¸€æ¬¡ï¼Œé˜²æ­¢åˆ·å±)
    // åŒæ—¶æ ¡å‡† AVSession è¿›åº¦
    if (diff % 10 === 0) {
       FileLogger.write('Tick', `å‰©ä½™: ${diff}s`);
       this.syncAVSession(diff);
    }

    if (diff <= 0) {
      this.secondsRemaining = 0;
      this.stopTimer(true);
    } else {
      this.secondsRemaining = diff;
      this.updateNotification();
      AppStorage.set('GS_SecondsRemaining', this.secondsRemaining);
    }
  }

  private async syncAVSession(secondsLeft: number) {
      if (!this.session) return;
      const elapsedTime = (this.totalSeconds - secondsLeft) * 1000;
      try {
          let playbackState: AVSessionManager.AVPlaybackState = {
            state: AVSessionManager.PlaybackState.PLAYBACK_STATE_PLAY,
            position: {
              elapsedTime: elapsedTime,
              updateTime: new Date().getTime()
            },
            speed: 1.0,
            bufferedTime: 0,
            duration: this.totalSeconds * 1000
          };
          await this.session.setAVPlaybackState(playbackState);
      } catch (e) { /* ignore */ }
  }

  private updateNotification() {
    const m = Math.floor(this.secondsRemaining / 60).toString().padStart(2, '0');
    const s = (this.secondsRemaining % 60).toString().padStart(2, '0');
    let progress = 0;
    if (this.totalSeconds > 0) {
      progress = Math.floor(((this.totalSeconds - this.secondsRemaining) / this.totalSeconds) * 100);
    }
    NotificationHelper.publishProgress(m, s, progress);
  }

  private syncToAppStorage(running: boolean) {
    AppStorage.set('GS_SecondsRemaining', this.secondsRemaining);
    AppStorage.set('GS_TotalSeconds', this.totalSeconds);
    AppStorage.set('GS_IsPaused', this.isPaused);
    AppStorage.set('GS_IsRunning', running);
  }

  // --- åå°æƒé™ç”³è¯· ---

  private async requestBackgroundTask() {
    if (!this.context) return;
    let wantAgentInfo: wantAgent.WantAgentInfo = {
      wants: [{ bundleName: this.context.abilityInfo.bundleName, abilityName: this.context.abilityInfo.name }],
      operationType: wantAgent.OperationType.START_ABILITY,
      requestCode: 0,
      wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
    };
    try {
      let agent = await wantAgent.getWantAgent(wantAgentInfo);
      await backgroundTaskManager.startBackgroundRunning(
        this.context,
        backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK,
        agent
      );
      FileLogger.write('System', 'åå°æƒé™ç”³è¯·æˆåŠŸ');
    } catch (e) {
      FileLogger.write('SystemError', 'åå°æƒé™ç”³è¯·å¤±è´¥: ' + JSON.stringify(e));
    }
  }

  private async stopBackgroundTask() {
    if (!this.context) return;
    try {
      await backgroundTaskManager.stopBackgroundRunning(this.context);
      FileLogger.write('System', 'åå°æƒé™å·²é‡Šæ”¾');
    } catch (e) {}
  }
}
